<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê°•ì•„ì§€ í‚¤ìš°ê¸°</title>
    <style>
        /* Pretendard ì›¹í°íŠ¸ ì¶”ê°€ */
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        
        body {
            background-color: #fdf6e3; /* ë¶€ë“œëŸ¬ìš´ í¬ë¦¼ìƒ‰ ë°°ê²½ */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Pretendard', 'Malgun Gothic', sans-serif;
            color: #5d4037; /* ê°ˆìƒ‰ í…ìŠ¤íŠ¸ */
            text-align: center;
            flex-direction: column;
            overflow: hidden;
        }

        #game-wrapper {
            position: relative;
            width: 95%;
            max-width: 800px;
            aspect-ratio: 4 / 3; /* 800x600 ë¹„ìœ¨ ìœ ì§€ */
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            border-radius: 20px;
            background: #fff;
            border: 10px solid #fff;
        }

        canvas {
            background-color: #a7e0e0; /* ë°ì€ í•˜ëŠ˜ìƒ‰ ë°°ê²½ */
            border-radius: 10px;
            cursor: pointer;
            width: 100%;
            height: 100%;
            display: block;
        }

        .hidden { display: none; }

        h1 {
            color: #d4a373; /* ë”°ëœ»í•œ ê°ˆìƒ‰ ì œëª© */
            margin-bottom: 15px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        /* ë¡œë”© í™”ë©´ ìŠ¤íƒ€ì¼ */
        #loading-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.9);
            color: #5d4037;
            display: flex;
            flex-direction: column; /* ì„¸ë¡œ ì •ë ¬ ì¶”ê°€ */
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 10;
            border-radius: 10px;
        }
    </style>
</head>
<body>

    <h1>ë‚˜ë§Œì˜ ëŒ•ëŒ•ì´ë¥¼ í‚¤ì›Œë³´ì„¸ìš”! ğŸ¾</h1>
    <div id="game-wrapper">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="loading-screen">
            <p>ë¡œë”© ì¤‘...</p>
            <p id="loading-status" style="font-size: 16px; margin-top: 10px;"></p>
        </div>
    </div>

    <audio id="bgm" loop class="hidden"></audio>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgm = document.getElementById('bgm');
    const loadingScreen = document.getElementById('loading-screen');
    const loadingStatus = document.getElementById('loading-status');

    // --- ê²Œì„ ìƒíƒœ ë° ì„¤ì • ---
    const BASE_URL = "";
    let gameState = 'LOADING';
    let dog = null;
    let gameTime = 0;
    let animationFrame = 0;
    let currentEvent = null;
    let dogNameInput = '';
    let lastLifecycleEventAge = -1;
    let musicStarted = false;
    let mousePos = { x: 0, y: 0 };
    let images = {};
    let errorMessage = null;

    const ASSETS = {
        bgm: 'bgm.mp3',
        bichon_newborn: 'b1.png', bichon_teen: 'b2.png', bichon_adult: 'b3.png', bichon_senior: 'b4.png',
        retriever_newborn: 'g1.png', retriever_teen: 'g2.png', retriever_adult: 'g3.png', retriever_senior: 'g4.png',
    };

    const breeds = {
        'ë¹„ìˆ‘ í”„ë¦¬ì œ': { images: { 'ì‹ ìƒì•„ê¸°': 'bichon_newborn', 'ì²­ì†Œë…„ê¸°': 'bichon_teen', 'ì„±ë…„ê¸°': 'bichon_adult', 'ë…¸ë ¹ê¸°': 'bichon_senior' } },
        'ê³¨ë“  ë¦¬íŠ¸ë¦¬ë²„': { images: { 'ì‹ ìƒì•„ê¸°': 'retriever_newborn', 'ì²­ì†Œë…„ê¸°': 'retriever_teen', 'ì„±ë…„ê¸°': 'retriever_adult', 'ë…¸ë ¹ê¸°': 'retriever_senior' } }
    };

    const lifecycle = [
        { age: 0, stage: "ì‹ ìƒì•„ê¸°", event: "ì„¸ìƒì— íƒœì–´ë‚¬ì–´ìš”! ì•ˆë…•?" },
        { age: 2, stage: "ì²­ì†Œë…„ê¸°", event: "ì—ë„ˆì§€ê°€ ë„˜ì³ìš”! 'ê°œë¦°ì´'ê°€ ë˜ì—ˆì–´ìš”." },
        { age: 6, stage: "ì„±ë…„ê¸°", event: "ëŠ ë¦„í•œ ì„±ê²¬ì´ ë˜ì—ˆì–´ìš”." },
        { age: 10, stage: "ë…¸ë ¹ê¸°", event: "ì´ì œëŠ” ì ì´ ë§ì•„ì¡Œì–´ìš”. ê³ì— ìˆì–´ì£¼ì„¸ìš”." }
    ];
    
    const randomEvents = [
        { text: "ì‚°ì±… ê°ˆ ì‹œê°„ì´ì—ìš”!", choices: [{ text: "ì‹ ë‚˜ê²Œ ë‹¬ë¦°ë‹¤", stat: 'intimacy', value: 10 }, { text: "ì²œì²œíˆ ê±·ëŠ”ë‹¤", stat: 'intimacy', value: 5 }], anim: drawWalkAnim },
        { text: "ëª©ìš•í•  ì‹œê°„! ë¬¼ì´ ì‹«ì–´ìš”!", choices: [{ text: "ë¶€ë“œëŸ½ê²Œ ì”»ê¸´ë‹¤", stat: 'intimacy', value: 5 }, { text: "ê°„ì‹ì„ ì£¼ë©° ë‹¬ëœë‹¤", stat: 'hunger', value: 10, stat2: 'intimacy', value2: 2 }], anim: drawBathAnim },
        { text: "ë°°ê°€ ê³ íŒŒìš”! ë°¥ ì£¼ì„¸ìš”!", choices: [{ text: "ì‚¬ë£Œë¥¼ ì¤€ë‹¤", stat: 'hunger', value: 20 }, { text: "íŠ¹ì‹ì„ ì¤€ë‹¤", stat: 'hunger', value: 30, stat2: 'intimacy', value2: 5 }], anim: drawEatAnim },
        { text: "ë†€ì•„ì£¼ì„¸ìš”!", choices: [{ text: "ê³µë†€ì´ë¥¼ í•œë‹¤", stat: 'intimacy', value: 15 }, { text: "í„°ê·¸ ë†€ì´ë¥¼ í•œë‹¤", stat: 'intimacy', value: 12 }], anim: drawPlayAnim }
    ];

    // --- ì—ì…‹ ë¡œë”© (ì˜¤ë””ì˜¤ ë¡œë”© ë¡œì§ ìˆ˜ì •) ---
    function loadAssets() {
        const promises = [];
        const assetKeys = Object.keys(ASSETS);
        assetKeys.forEach(key => {
            const path = BASE_URL + ASSETS[key];
            if (key === 'bgm') {
                bgm.src = path;
                promises.push(new Promise(resolve => {
                    bgm.addEventListener('canplaythrough', () => {
                        loadingStatus.textContent = `'${ASSETS[key]}' ë¡œë”© ì™„ë£Œ!`;
                        console.log(`ì˜¤ë””ì˜¤ ë¡œë”© ì™„ë£Œ: ${path}`);
                        resolve({key, status: 'ok'});
                    }, { once: true });
                    bgm.addEventListener('error', (e) => {
                        loadingStatus.textContent = `'${ASSETS[key]}' ë¡œë”© ì‹¤íŒ¨!`;
                        console.error(`ì˜¤ë””ì˜¤ ë¡œë”© ì‹¤íŒ¨: ${path}`, e);
                        resolve({key, status: 'error'});
                    }, { once: true });
                }));
            } else {
                const img = new Image();
                images[key] = img;
                promises.push(new Promise(resolve => {
                    img.onload = () => {
                        loadingStatus.textContent = `'${ASSETS[key]}' ë¡œë”© ì™„ë£Œ!`;
                        console.log(`ì„±ê³µ: ${path}`);
                        resolve({key, status: 'ok'});
                    };
                    img.onerror = () => {
                        loadingStatus.textContent = `'${ASSETS[key]}' ë¡œë”© ì‹¤íŒ¨!`;
                        console.error(`ì‹¤íŒ¨: ${path} íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                        resolve({key, status: 'error'});
                    };
                    img.src = path;
                }));
            }
        });
        return Promise.all(promises);
    }

    // --- ê·¸ë¦¬ê¸° í•¨ìˆ˜ ---
    function drawBackground() {
        ctx.fillStyle = '#f4a261'; ctx.fillRect(0, 450, canvas.width, 150);
        ctx.fillStyle = '#e9c46a'; ctx.fillRect(0, 0, canvas.width, 450);
        ctx.fillStyle = '#a2d2ff'; ctx.fillRect(550, 100, 150, 100);
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 5; ctx.strokeRect(550, 100, 150, 100);
        ctx.beginPath(); ctx.moveTo(625, 100); ctx.lineTo(625, 200);
        ctx.moveTo(550, 150); ctx.lineTo(700, 150); ctx.stroke();
    }

    function drawDog() {
        if (!dog) return;
        let stageInfo = lifecycle[0];
        for(const stage of lifecycle) {
            if (dog.age >= stage.age) {
                stageInfo = stage;
            } else {
                break;
            }
        }
        dog.stage = stageInfo.stage;
        
        const imageName = breeds[dog.breed].images[dog.stage];
        const img = images[imageName];
        if (!img || !img.complete || img.naturalHeight === 0) {
            ctx.fillStyle = '#d90429';
            ctx.font = '16px "Pretendard"';
            ctx.textAlign = 'center';
            ctx.fillText(`'${ASSETS[imageName]}' ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ì–´ìš”!`, canvas.width / 2, canvas.height / 2);
            return;
        }

        const bobbing = Math.sin(animationFrame * 0.05) * 5;
        const scale = 0.6 + (dog.age / 15) * 0.2;
        const imgWidth = img.width * scale;
        const imgHeight = img.height * scale;
        const dogX = canvas.width / 2 - imgWidth / 2;
        const dogY = canvas.height - imgHeight - 50 + bobbing;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.beginPath();
        ctx.ellipse(canvas.width / 2, canvas.height - 40, imgWidth / 2, 10);
        ctx.fill();

        ctx.drawImage(img, dogX, dogY, imgWidth, imgHeight);
    }

    function drawUI() { 
        if (gameState !== 'PLAYING') return;
        ctx.save();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.strokeStyle = '#d4a373';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(10, 10, 320, 120, 15);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#5d4037';
        ctx.font = 'bold 22px "Pretendard", "Malgun Gothic", sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`ğŸ¾ ${dog.name}`, 25, 45);
        ctx.font = '18px "Pretendard", "Malgun Gothic", sans-serif';
        ctx.fillText(`ğŸ‚ ${dog.age}ì‚´ (${dog.stage})`, 25, 75);
        const drawGauge = (label, value, color, y) => {
            ctx.fillText(label, 25, y + 12);
            ctx.fillStyle = '#e0e0e0';
            ctx.beginPath(); ctx.roundRect(110, y, 190, 18, 9); ctx.fill();
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.roundRect(110, y, Math.max(0, value) * 1.9, 18, 9); ctx.fill();
            ctx.fillStyle = '#5d4037';
        };
        drawGauge('ì¹œë°€ë„', dog.stats.intimacy, '#ff8fab', 95);
        drawGauge('ë°°ê³ í””', dog.stats.hunger, '#fca311', 120);
        ctx.restore();
    }

    function drawWalkAnim() { /* ... */ }
    function drawBathAnim() { /* ... */ }
    function drawEatAnim() { /* ... */ }
    function drawPlayAnim() { /* ... */ }
    function drawButton(text, x, y, width, height, hover) { /* ... */ }
    function drawEvent() { /* ... */ }
    function drawScreen(title, subtitle) { /* ... */ }
    function drawBreedSelection() { /* ... */ }
    function drawNamingScreen() { /* ... */ }

    // --- (ì´í•˜ ë‚˜ë¨¸ì§€ ì½”ë“œëŠ” ì´ì „ê³¼ ë™ì¼í•©ë‹ˆë‹¤) ---
    function update() {
        animationFrame++;
        if (gameState !== 'PLAYING' || currentEvent) return;
        gameTime++;
        if (gameTime % 3600 === 0) { dog.age++; checkLifecycle(); }
        if (gameTime % 60 === 0) {
            dog.stats.hunger = Math.max(0, dog.stats.hunger - 0.5);
            dog.stats.intimacy = Math.max(0, dog.stats.intimacy - 0.2);
        }
        if (gameTime > 300 && gameTime % 600 === 0) triggerRandomEvent();
    }
    function checkLifecycle() {
        const currentStage = lifecycle.find(s => dog.age === s.age);
        if (currentStage && dog.age > lastLifecycleEventAge) {
            lastLifecycleEventAge = dog.age;
            dog.stage = currentStage.stage;
            currentEvent = { text: currentStage.event, choices: [{ text: "ì•Œì•˜ì–´!" }], isLifecycle: true };
        }
    }
    function triggerRandomEvent() {
        if (currentEvent) return;
        const eventIndex = Math.floor(Math.random() * randomEvents.length);
        currentEvent = JSON.parse(JSON.stringify(randomEvents[eventIndex]));
        currentEvent.anim = randomEvents[eventIndex].anim;
    }
    function selectEventChoice(choice) {
        if (choice.stat) dog.stats[choice.stat] = Math.min(100, dog.stats[choice.stat] + choice.value);
        if (choice.stat2) dog.stats[choice.stat2] = Math.min(100, dog.stats[choice.stat2] + choice.value2);
        currentEvent = null;
    }
    function isMouseOver(rect) {
        if (!rect) return false;
        return mousePos.x > rect.x && mousePos.x < rect.x + rect.width &&
               mousePos.y > rect.y && mousePos.y < rect.y + rect.height;
    }
    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        update();
        if (gameState === 'PLAYING') {
            drawBackground(); drawDog(); drawUI();
            if (currentEvent) drawEvent();
        } else if (gameState === 'START_SCREEN') {
            drawScreen('ê°•ì•„ì§€ í‚¤ìš°ê¸°', 'í´ë¦­í•´ì„œ ì‹œì‘í•˜ê¸°');
        } else if (gameState === 'CHOOSE_BREED') {
            drawBreedSelection();
        } else if (gameState === 'NAMING') {
            drawNamingScreen();
        } else if (gameState === 'ERROR') {
            ctx.fillStyle = '#fdf6e3';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#d90429';
            ctx.font = 'bold 24px "Pretendard", "Malgun Gothic", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(errorMessage, canvas.width / 2, canvas.height / 2);
        }
        requestAnimationFrame(gameLoop);
    }
    function handleCanvasClick(e) {
        if (!musicStarted) {
            bgm.volume = 0.3;
            bgm.play().catch(err => console.error("BGM ì¬ìƒ ì‹¤íŒ¨:", err));
            musicStarted = true;
        }
        if (gameState === 'START_SCREEN') {
            gameState = 'CHOOSE_BREED';
        } else if (gameState === 'CHOOSE_BREED') {
            Object.keys(breeds).forEach(breed => {
                if (isMouseOver(breeds[breed].btn)) {
                    dog = { breed: breed, name: '', age: 0, stage: 'ì‹ ìƒì•„ê¸°', stats: { intimacy: 50, hunger: 50 } };
                    gameState = 'NAMING';
                }
            });
        } else if (gameState === 'PLAYING' && currentEvent) {
            currentEvent.choices.forEach(choice => {
                if (isMouseOver(choice)) selectEventChoice(choice);
            });
        }
    }
    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        mousePos.x = (e.clientX - rect.left) * scaleX;
        mousePos.y = (e.clientY - rect.top) * scaleY;
    }
    function handleKeyDown(e) {
        if (gameState !== 'NAMING') return;
        if (e.key === 'Enter' && dogNameInput.length > 0) {
            dog.name = dogNameInput;
            gameState = 'PLAYING';
            checkLifecycle();
        } else if (e.key === 'Backspace') {
            dogNameInput = dogNameInput.slice(0, -1);
        } else if (e.key.length === 1 && dogNameInput.length < 10 && /^[ã„±-ã…ê°€-í£a-zA-Z0-9\s]$/.test(e.key)) {
            dogNameInput += e.key;
        }
    }
    
    // [FIX] init í•¨ìˆ˜ë¥¼ async/await ëŒ€ì‹  .then()ì„ ì‚¬ìš©í•˜ì—¬ ë¡œë”© ì™„ë£Œ í›„ ê²Œì„ì„ ì‹œì‘í•˜ë„ë¡ ìˆ˜ì •
    function init() {
        console.log("init() ì‹œì‘");
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('keydown', handleKeyDown);
        
        console.log("loadAssets() í˜¸ì¶œ");
        loadAssets().then(assetResults => {
            console.log("ëª¨ë“  ì—ì…‹ ë¡œë”© ì‹œë„ ì™„ë£Œ, .then() ë¸”ë¡ ì§„ì…");

            const failedAssets = assetResults.filter(r => r.status === 'error');
            if (failedAssets.length > 0) {
                throw new Error(`${failedAssets.map(f=>f.key).join(', ')} íŒŒì¼ ë¡œë”© ì‹¤íŒ¨`);
            }
            
            loadingScreen.classList.add('hidden');
            console.log("ë¡œë”© í™”ë©´ ìˆ¨ê¹€");

            gameState = 'START_SCREEN';
            console.log("gameStateë¥¼ START_SCREENìœ¼ë¡œ ì„¤ì •");

            gameLoop();
            console.log("gameLoop() ìµœì´ˆ í˜¸ì¶œ");

        }).catch(error => {
            console.error("ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
            errorMessage = `ê²Œì„ ì´ˆê¸°í™” ì˜¤ë¥˜: ${error.message}. ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”.`;
            loadingScreen.innerHTML = `<p>${errorMessage}</p>`;
            gameState = 'ERROR';
            // ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ gameLoopë¥¼ í˜¸ì¶œí•˜ì—¬ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ìº”ë²„ìŠ¤ì— í‘œì‹œ
            gameLoop();
        });
    }

    init();
</script>
</body>
</html>
